(window.webpackJsonp=window.webpackJsonp||[]).push([[61],{136:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return s})),n.d(t,"metadata",(function(){return r})),n.d(t,"toc",(function(){return c})),n.d(t,"default",(function(){return d}));var a=n(3),o=n(8),i=(n(0),n(158)),s=(n(160),{id:"part-4-using-data",title:"Redux \ud575\uc2ec, Part 4: Using Redux Data",sidebar_label:"Using Redux Data",hide_title:!0,description:"The official Redux \ud575\uc2ec \ud29c\ud1a0\ub9ac\uc5bc: learn how to work with complex Redux state in React components"}),r={unversionedId:"tutorials/essentials/part-4-using-data",id:"tutorials/essentials/part-4-using-data",isDocsHomePage:!1,title:"Redux \ud575\uc2ec, Part 4: Using Redux Data",description:"The official Redux \ud575\uc2ec \ud29c\ud1a0\ub9ac\uc5bc: learn how to work with complex Redux state in React components",source:"@site/i18n/ko/docusaurus-plugin-content-docs/current/tutorials/essentials/part-4-using-data.md",slug:"/tutorials/essentials/part-4-using-data",permalink:"/tutorials/essentials/part-4-using-data",version:"current",sidebar_label:"Using Redux Data",sidebar:"docs",previous:{title:"Redux \ud575\uc2ec, Part 3: Basic Redux Data Flow",permalink:"/tutorials/essentials/part-3-data-flow"},next:{title:"Redux \ud575\uc2ec, Part 5: Async Logic and Data Fetching",permalink:"/tutorials/essentials/part-5-async-logic"}},c=[{value:"Introduction",id:"introduction",children:[]},{value:"Showing Single Posts",id:"showing-single-posts",children:[{value:"Creating a Single Post Page",id:"creating-a-single-post-page",children:[]},{value:"Adding the Single Post Route",id:"adding-the-single-post-route",children:[]}]},{value:"Editing Posts",id:"editing-posts",children:[{value:"Updating Post Entries",id:"updating-post-entries",children:[]},{value:"Creating an Edit Post Form",id:"creating-an-edit-post-form",children:[]},{value:"Preparing Action Payloads",id:"preparing-action-payloads",children:[]}]},{value:"Users and Posts",id:"users-and-posts",children:[{value:"Adding a Users Slice",id:"adding-a-users-slice",children:[]},{value:"Adding Authors for Posts",id:"adding-authors-for-posts",children:[]}]},{value:"More Post Features",id:"more-post-features",children:[{value:"Storing Dates for Posts",id:"storing-dates-for-posts",children:[]},{value:"Sorting the Posts List",id:"sorting-the-posts-list",children:[]},{value:"Post Reaction Buttons",id:"post-reaction-buttons",children:[]}]},{value:"What You&#39;ve Learned",id:"what-youve-learned",children:[]},{value:"What&#39;s Next?",id:"whats-next",children:[]}],l={toc:c};function d(e){var t=e.components,n=Object(o.a)(e,["components"]);return Object(i.b)("wrapper",Object(a.a)({},l,n,{components:t,mdxType:"MDXLayout"}),Object(i.b)("h1",{id:"redux-\ud575\uc2ec-part-4-using-redux-data"},"Redux \ud575\uc2ec, Part 4: Using Redux Data"),Object(i.b)("div",{className:"admonition admonition-tip alert alert--success"},Object(i.b)("div",{parentName:"div",className:"admonition-heading"},Object(i.b)("h5",{parentName:"div"},Object(i.b)("span",{parentName:"h5",className:"admonition-icon"},Object(i.b)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},Object(i.b)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"What You'll Learn")),Object(i.b)("div",{parentName:"div",className:"admonition-content"},Object(i.b)("ul",{parentName:"div"},Object(i.b)("li",{parentName:"ul"},"Using Redux data in multiple React components"),Object(i.b)("li",{parentName:"ul"},"Organizing logic that dispatches actions"),Object(i.b)("li",{parentName:"ul"},"Writing more complex update logic in reducers")))),Object(i.b)("div",{className:"admonition admonition-info alert alert--info"},Object(i.b)("div",{parentName:"div",className:"admonition-heading"},Object(i.b)("h5",{parentName:"div"},Object(i.b)("span",{parentName:"h5",className:"admonition-icon"},Object(i.b)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},Object(i.b)("path",{parentName:"svg",fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}))),"Prerequisites")),Object(i.b)("div",{parentName:"div",className:"admonition-content"},Object(i.b)("ul",{parentName:"div"},Object(i.b)("li",{parentName:"ul"},"Understanding the ",Object(i.b)("a",{parentName:"li",href:"/tutorials/essentials/part-3-data-flow"},"Redux data flow and React-Redux APIs from Part 3")),Object(i.b)("li",{parentName:"ul"},"Familiarity with ",Object(i.b)("a",{parentName:"li",href:"https://reacttraining.com/react-router/web/api"},"the React Router ",Object(i.b)("inlineCode",{parentName:"a"},"<Link>")," and ",Object(i.b)("inlineCode",{parentName:"a"},"<Route>")," components for page routing"))))),Object(i.b)("h2",{id:"introduction"},"Introduction"),Object(i.b)("p",null,"In ",Object(i.b)("a",{parentName:"p",href:"/tutorials/essentials/part-3-data-flow"},"Part 3: Basic Redux Data Flow"),", we saw how to start from an empty Redux+React project setup, add a new slice of state, and create React components that can read data from the Redux store and dispatch actions to update that data. We also looked at how data flows through the application, with components dispatching actions, reducers processing actions and returning new state, and components reading the new state and rerendering the UI."),Object(i.b)("p",null,"Now that you know the core steps to write Redux logic, we're going to use those same steps to add some new features to our social media feed that will make it more useful: viewing a single post, editing existing posts, showing post author details, post timestamps, and reaction buttons."),Object(i.b)("div",{className:"admonition admonition-info alert alert--info"},Object(i.b)("div",{parentName:"div",className:"admonition-heading"},Object(i.b)("h5",{parentName:"div"},Object(i.b)("span",{parentName:"h5",className:"admonition-icon"},Object(i.b)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},Object(i.b)("path",{parentName:"svg",fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}))),"info")),Object(i.b)("div",{parentName:"div",className:"admonition-content"},Object(i.b)("p",{parentName:"div"},"As a reminder, the code examples focus on the key concepts and changes for each section. See the CodeSandbox projects and the ",Object(i.b)("a",{parentName:"p",href:"https://github.com/reduxjs/redux-essentials-example-app/tree/tutorial-steps"},Object(i.b)("inlineCode",{parentName:"a"},"tutorial-steps")," branch in the project repo")," for the complete changes in the application."))),Object(i.b)("h2",{id:"showing-single-posts"},"Showing Single Posts"),Object(i.b)("p",null,"Since we have the ability to add new posts to the Redux store, we can add some more features that use the post data in different ways."),Object(i.b)("p",null,"Currently, our post entries are being shown in the main feed page, but if the text is too long, we only show an excerpt of the content. It would be helpful to have the ability to view a single post entry on its own page."),Object(i.b)("h3",{id:"creating-a-single-post-page"},"Creating a Single Post Page"),Object(i.b)("p",null,"First, we need to add a new ",Object(i.b)("inlineCode",{parentName:"p"},"SinglePostPage")," component to our ",Object(i.b)("inlineCode",{parentName:"p"},"posts")," feature folder. We'll use React Router to show this component when the page URL looks like ",Object(i.b)("inlineCode",{parentName:"p"},"/posts/123"),", where the ",Object(i.b)("inlineCode",{parentName:"p"},"123")," part should be the ID of the post we want to show."),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-jsx",metastring:'title="features/posts/SinglePostPage.js"',title:'"features/posts/SinglePostPage.js"'},"import React from 'react'\nimport { useSelector } from 'react-redux'\n\nexport const SinglePostPage = ({ match }) => {\n  const { postId } = match.params\n\n  const post = useSelector(state =>\n    state.posts.find(post => post.id === postId)\n  )\n\n  if (!post) {\n    return (\n      <section>\n        <h2>Post not found!</h2>\n      </section>\n    )\n  }\n\n  return (\n    <section>\n      <article className=\"post\">\n        <h2>{post.title}</h2>\n        <p className=\"post-content\">{post.content}</p>\n      </article>\n    </section>\n  )\n}\n")),Object(i.b)("p",null,"React Router will pass in a ",Object(i.b)("inlineCode",{parentName:"p"},"match")," object as a prop that contains the URL information we're looking for. When we set up the route to render this component, we're going to tell it to parse the second part of the URL as a variable named ",Object(i.b)("inlineCode",{parentName:"p"},"postId"),", and we can read that value from ",Object(i.b)("inlineCode",{parentName:"p"},"match.params"),"."),Object(i.b)("p",null,"Once we have that ",Object(i.b)("inlineCode",{parentName:"p"},"postId")," value, we can use it inside a selector function to find the right post object from the Redux store. We know that ",Object(i.b)("inlineCode",{parentName:"p"},"state.posts")," should be an array of all post objects, so we can use the ",Object(i.b)("inlineCode",{parentName:"p"},"Array.find()")," function to loop through the array and return the post entry with the ID we're looking for."),Object(i.b)("p",null,"It's important to note that ",Object(i.b)("strong",{parentName:"p"},"the component will re-render any time the value returned from ",Object(i.b)("inlineCode",{parentName:"strong"},"useSelector")," changes to a new reference"),". Components should always try to select the smallest possible amount of data they need from the store, which will help ensure that it only renders when it actually needs to."),Object(i.b)("p",null,"It's possible that we might not have a matching post entry in the store - maybe the user tried to type in the URL directly, or we don't have the right data loaded. If that happens, the ",Object(i.b)("inlineCode",{parentName:"p"},"find()")," function will return ",Object(i.b)("inlineCode",{parentName:"p"},"undefined"),' instead of an actual post object. Our component needs to check for that and handle it by showing a "Post not found!" message in the page.'),Object(i.b)("p",null,"Assuming we do have the right post object in the store, ",Object(i.b)("inlineCode",{parentName:"p"},"useSelector")," will return that, and we can use it to render the title and content of the post in the page."),Object(i.b)("p",null,"You might notice that this looks fairly similar to the logic we have in the body of our ",Object(i.b)("inlineCode",{parentName:"p"},"<PostsList>")," component, where we loop over the whole ",Object(i.b)("inlineCode",{parentName:"p"},"posts")," array to show post excerpts the main feed. We ",Object(i.b)("em",{parentName:"p"},"could")," try to extract a ",Object(i.b)("inlineCode",{parentName:"p"},"Post")," component that could be used in both places, but there are already some differences in how we're showing a post excerpt and the whole post. It's usually better to keep writing things separately for a while even if there's some duplication, and then we can decide later if the different sections of code are similar enough that we can really extract a reusable component."),Object(i.b)("h3",{id:"adding-the-single-post-route"},"Adding the Single Post Route"),Object(i.b)("p",null,"Now that we have a ",Object(i.b)("inlineCode",{parentName:"p"},"<SinglePostPage>")," component, we can define a route to show it, and add links to each post in the front page feed."),Object(i.b)("p",null,"We'll import ",Object(i.b)("inlineCode",{parentName:"p"},"SinglePostPage")," in ",Object(i.b)("inlineCode",{parentName:"p"},"App.js"),", and add the route:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-jsx",metastring:'title="App.js"',title:'"App.js"'},'import { PostsList } from \'./features/posts/PostsList\'\nimport { AddPostForm } from \'./features/posts/AddPostForm\'\n// highlight-next-line\nimport { SinglePostPage } from \'./features/posts/SinglePostPage\'\n\nfunction App() {\n  return (\n    <Router>\n      <Navbar />\n      <div className="App">\n        <Switch>\n          <Route\n            exact\n            path="/"\n            render={() => (\n              <React.Fragment>\n                <AddPostForm />\n                <PostsList />\n              </React.Fragment>\n            )}\n          />\n          // highlight-next-line\n          <Route exact path="/posts/:postId" component={SinglePostPage} />\n          <Redirect to="/" />\n        </Switch>\n      </div>\n    </Router>\n  )\n}\n')),Object(i.b)("p",null,"Then, in ",Object(i.b)("inlineCode",{parentName:"p"},"<PostsList>"),", we'll update the list rendering logic to include a ",Object(i.b)("inlineCode",{parentName:"p"},"<Link>")," that routes to that specific post:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-jsx",metastring:'title="features/posts/PostsList.js"',title:'"features/posts/PostsList.js"'},'import React from \'react\'\nimport { useSelector } from \'react-redux\'\n// highlight-next-line\nimport { Link } from \'react-router-dom\'\n\nexport const PostsList = () => {\n  const posts = useSelector(state => state.posts)\n\n  const renderedPosts = posts.map(post => (\n    <article className="post-excerpt" key={post.id}>\n      <h3>{post.title}</h3>\n      <p className="post-content">{post.content.substring(0, 100)}</p>\n      // highlight-start\n      <Link to={`/posts/${post.id}`} className="button muted-button">\n        View Post\n      </Link>\n      // highlight-end\n    </article>\n  ))\n\n  return (\n    <section className="posts-list">\n      <h2>Posts</h2>\n      {renderedPosts}\n    </section>\n  )\n}\n')),Object(i.b)("p",null,"And since we can now click through to a different page, it would also be helpful to have a link back to the main posts page in the ",Object(i.b)("inlineCode",{parentName:"p"},"<Navbar>")," component as well:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-jsx",metastring:'title="app/Navbar.js"',title:'"app/Navbar.js"'},'import React from \'react\'\n\n// highlight-next-line\nimport { Link } from \'react-router-dom\'\n\nexport const Navbar = () => {\n  return (\n    <nav>\n      <section>\n        <h1>Redux \ud575\uc2ec Example</h1>\n\n        <div className="navContent">\n          // highlight-start\n          <div className="navLinks">\n            <Link to="/">Posts</Link>\n          </div>\n          // highlight-end\n        </div>\n      </section>\n    </nav>\n  )\n}\n')),Object(i.b)("h2",{id:"editing-posts"},"Editing Posts"),Object(i.b)("p",null,"As a user, it's really annoying to finish writing a post, save it, and realize you made a mistake somewhere. Having the ability to edit a post after we created it would be useful."),Object(i.b)("p",null,"Let's add a new ",Object(i.b)("inlineCode",{parentName:"p"},"<EditPostForm>")," component that has the ability to take an existing post ID, read that post from the store, lets the user edit the title and post content, and then save the changes to update the post in the store."),Object(i.b)("h3",{id:"updating-post-entries"},"Updating Post Entries"),Object(i.b)("p",null,"First, we need to update our ",Object(i.b)("inlineCode",{parentName:"p"},"postsSlice")," to create a new reducer function and an action so that the store knows how to actually update posts."),Object(i.b)("p",null,"Inside of the ",Object(i.b)("inlineCode",{parentName:"p"},"createSlice()")," call, we should add a new function into the ",Object(i.b)("inlineCode",{parentName:"p"},"reducers")," object. Remember that the name of this reducer should be a good description of what's happening, because we're going to see the reducer name show up as part of the action type string in the Redux DevTools whenever this action is dispatched. Our first reducer was called ",Object(i.b)("inlineCode",{parentName:"p"},"postAdded"),", so let's call this one ",Object(i.b)("inlineCode",{parentName:"p"},"postUpdated"),"."),Object(i.b)("p",null,"In order to update a post object, we need to know:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"The ID of the post being updated, so that we can find the right post object in the state"),Object(i.b)("li",{parentName:"ul"},"The new ",Object(i.b)("inlineCode",{parentName:"li"},"title")," and ",Object(i.b)("inlineCode",{parentName:"li"},"content")," fields that the user typed in")),Object(i.b)("p",null,"Redux action objects are required to have a ",Object(i.b)("inlineCode",{parentName:"p"},"type")," field, which is normally a descriptive string, and may also contain other fields with more information about what happened. By convention, we normally put the additional info in a field called ",Object(i.b)("inlineCode",{parentName:"p"},"action.payload"),", but it's up to us to decide what the ",Object(i.b)("inlineCode",{parentName:"p"},"payload")," field contains - it could be a string, a number, an object, an array, or something else. In this case, since we have three pieces of information we need, let's plan on having the ",Object(i.b)("inlineCode",{parentName:"p"},"payload")," field be an object with the three fields inside of it. That means the action object will look like ",Object(i.b)("inlineCode",{parentName:"p"},"{type: 'posts/postUpdated', payload: {id, title, content}}"),"."),Object(i.b)("p",null,"By default, the action creators generated by ",Object(i.b)("inlineCode",{parentName:"p"},"createSlice")," expect you to pass in one argument, and that value will be put into the action object as ",Object(i.b)("inlineCode",{parentName:"p"},"action.payload"),". So, we can pass an object containing those fields as the argument to the ",Object(i.b)("inlineCode",{parentName:"p"},"postUpdated")," action creator."),Object(i.b)("p",null,"We also know that the reducer is responsible for determining how the state should actually be updated when an action is dispatched. Given that, we should have the reducer find the right post object based on the ID, and specifically update the ",Object(i.b)("inlineCode",{parentName:"p"},"title")," and ",Object(i.b)("inlineCode",{parentName:"p"},"content")," fields in that post."),Object(i.b)("p",null,"Finally, we'll need to export the action creator function that ",Object(i.b)("inlineCode",{parentName:"p"},"createSlice")," generated for us, so that the UI can dispatch the new ",Object(i.b)("inlineCode",{parentName:"p"},"postUpdated")," action when the user saves the post."),Object(i.b)("p",null,"Given all those requirements, here's how our ",Object(i.b)("inlineCode",{parentName:"p"},"postsSlice")," definition should look after we're done:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-js",metastring:'title="features/posts/postsSlice.js"',title:'"features/posts/postsSlice.js"'},"const postsSlice = createSlice({\n  name: 'posts',\n  initialState,\n  reducers: {\n    postAdded(state, action) {\n      state.push(action.payload)\n    },\n    // highlight-start\n    postUpdated(state, action) {\n      const { id, title, content } = action.payload\n      const existingPost = state.find(post => post.id === id)\n      if (existingPost) {\n        existingPost.title = title\n        existingPost.content = content\n      }\n    }\n    // highlight-end\n  }\n})\n\n// highlight-next-line\nexport const { postAdded, postUpdated } = postsSlice.actions\n\nexport default postsSlice.reducer\n")),Object(i.b)("h3",{id:"creating-an-edit-post-form"},"Creating an Edit Post Form"),Object(i.b)("p",null,"Our new ",Object(i.b)("inlineCode",{parentName:"p"},"<EditPostForm>")," component will look similar to the ",Object(i.b)("inlineCode",{parentName:"p"},"<AddPostForm>"),", but the logic needs to be a bit different. We need to retrieve the right ",Object(i.b)("inlineCode",{parentName:"p"},"post")," object from the store, then use that to initialize the state fields in the component so the user can make changes. We'll save the changed title and content values back to the store after the user is done. We'll also use React Router's history API to switch over to the single post page and show that post."),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-jsx",metastring:'title="features/posts/EditPostForm.js"',title:'"features/posts/EditPostForm.js"'},'import React, { useState } from \'react\'\nimport { useDispatch, useSelector } from \'react-redux\'\nimport { useHistory } from \'react-router-dom\'\n\nimport { postUpdated } from \'./postsSlice\'\n\nexport const EditPostForm = ({ match }) => {\n  const { postId } = match.params\n\n  const post = useSelector(state =>\n    state.posts.find(post => post.id === postId)\n  )\n\n  const [title, setTitle] = useState(post.title)\n  const [content, setContent] = useState(post.content)\n\n  const dispatch = useDispatch()\n  const history = useHistory()\n\n  const onTitleChanged = e => setTitle(e.target.value)\n  const onContentChanged = e => setContent(e.target.value)\n\n  const onSavePostClicked = () => {\n    if (title && content) {\n      dispatch(postUpdated({ id: postId, title, content }))\n      history.push(`/posts/${postId}`)\n    }\n  }\n\n  return (\n    <section>\n      <h2>Edit Post</h2>\n      <form>\n        <label htmlFor="postTitle">Post Title:</label>\n        <input\n          type="text"\n          id="postTitle"\n          name="postTitle"\n          placeholder="What\'s on your mind?"\n          value={title}\n          onChange={onTitleChanged}\n        />\n        <label htmlFor="postContent">Content:</label>\n        <textarea\n          id="postContent"\n          name="postContent"\n          value={content}\n          onChange={onContentChanged}\n        />\n      </form>\n      <button type="button" onClick={onSavePostClicked}>\n        Save Post\n      </button>\n    </section>\n  )\n}\n')),Object(i.b)("p",null,"Like with ",Object(i.b)("inlineCode",{parentName:"p"},"SinglePostPage"),", we'll need to import it into ",Object(i.b)("inlineCode",{parentName:"p"},"App.js")," and add a route that will render this component. We should also add a new link to our ",Object(i.b)("inlineCode",{parentName:"p"},"SinglePostPage")," that will route to ",Object(i.b)("inlineCode",{parentName:"p"},"EditPostPage"),", like:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-jsx",metastring:'title="features/post/SinglePostPage.js"',title:'"features/post/SinglePostPage.js"'},'// highlight-next-line\nimport { Link } from \'react-router-dom\'\n\nexport const SinglePostPage = ({ match }) => {\n\n        // omit other contents\n\n        <p  className="post-content">{post.content}</p>\n        // highlight-start\n        <Link to={`/editPost/${post.id}`} className="button">\n          Edit Post\n        </Link>\n        // highlight-end\n')),Object(i.b)("h3",{id:"preparing-action-payloads"},"Preparing Action Payloads"),Object(i.b)("p",null,"We just saw that the action creators from ",Object(i.b)("inlineCode",{parentName:"p"},"createSlice")," normally expect one argument, which becomes ",Object(i.b)("inlineCode",{parentName:"p"},"action.payload.")," This simplifies the most common usage pattern, but sometimes we need to do more work to prepare the contents of an action object. In the case of our ",Object(i.b)("inlineCode",{parentName:"p"},"postAdded")," action, we need to generate a unique ID for the new post, and we also need to make sure that the payload is an object that looks like ",Object(i.b)("inlineCode",{parentName:"p"},"{id, title, content}"),"."),Object(i.b)("p",null,"Right now, we're generating the ID and creating the payload object in our React component, and passing the payload object into ",Object(i.b)("inlineCode",{parentName:"p"},"postAdded"),". But, what if we needed to dispatch the same action from different components, or the logic for preparing the payload is complicated? We'd have to duplicate that logic every time we wanted to dispatch the action, and we're forcing the component to know exactly what the payload for this action should look like."),Object(i.b)("div",{className:"admonition admonition-caution alert alert--warning"},Object(i.b)("div",{parentName:"div",className:"admonition-heading"},Object(i.b)("h5",{parentName:"div"},Object(i.b)("span",{parentName:"h5",className:"admonition-icon"},Object(i.b)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"16",height:"16",viewBox:"0 0 16 16"},Object(i.b)("path",{parentName:"svg",fillRule:"evenodd",d:"M8.893 1.5c-.183-.31-.52-.5-.887-.5s-.703.19-.886.5L.138 13.499a.98.98 0 0 0 0 1.001c.193.31.53.501.886.501h13.964c.367 0 .704-.19.877-.5a1.03 1.03 0 0 0 .01-1.002L8.893 1.5zm.133 11.497H6.987v-2.003h2.039v2.003zm0-3.004H6.987V5.987h2.039v4.006z"}))),"caution")),Object(i.b)("div",{parentName:"div",className:"admonition-content"},Object(i.b)("p",{parentName:"div"},"If an action needs to contain a unique ID or some other random value, always generate that first and put it in the action object. ",Object(i.b)("strong",{parentName:"p"},"Reducers should never calculate random values"),", because that makes the results unpredictable."))),Object(i.b)("p",null,"If we were writing the ",Object(i.b)("inlineCode",{parentName:"p"},"postAdded")," action creator by hand, we could have put the setup logic inside of it ourselves:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-js"},"// hand-written action creator\nfunction postAdded(title, content) {\n  const id = nanoid()\n  return {\n    type: 'posts/postAdded',\n    payload: { id, title, content }\n  }\n}\n")),Object(i.b)("p",null,"But, Redux Toolkit's ",Object(i.b)("inlineCode",{parentName:"p"},"createSlice")," is generating these action creators for us. That makes the code shorter because we don't have to write them ourselves, but we still need a way to customize the contents of ",Object(i.b)("inlineCode",{parentName:"p"},"action.payload"),"."),Object(i.b)("p",null,"Fortunately, ",Object(i.b)("inlineCode",{parentName:"p"},"createSlice"),' lets us define a "prepare callback" function when we write a reducer. The "prepare callback" function can take multiple arguments, generate random values like unique IDs, and run whatever other synchronous logic is needed to decide what values go into the action object. It should then return an object with the ',Object(i.b)("inlineCode",{parentName:"p"},"payload")," field inside. (The return object may also contain a ",Object(i.b)("inlineCode",{parentName:"p"},"meta")," field, which can be used to add extra descriptive values to the action, and an ",Object(i.b)("inlineCode",{parentName:"p"},"error")," field, which should be a boolean indicating whether this action represents some kind of an error.)"),Object(i.b)("p",null,"Inside of the ",Object(i.b)("inlineCode",{parentName:"p"},"reducers")," field in ",Object(i.b)("inlineCode",{parentName:"p"},"createSlice"),", we can define one of the fields as an object that looks like ",Object(i.b)("inlineCode",{parentName:"p"},"{reducer, prepare}"),":"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-js",metastring:'title="features/posts/postsSlice.js"',title:'"features/posts/postsSlice.js"'},"const postsSlice = createSlice({\n  name: 'posts',\n  initialState,\n  reducers: {\n    // highlight-start\n    postAdded: {\n      reducer(state, action) {\n        state.push(action.payload)\n      },\n      prepare(title, content) {\n        return {\n          payload: {\n            id: nanoid(),\n            title,\n            content\n          }\n        }\n      }\n    }\n    // highlight-end\n    // other reducers here\n  }\n})\n")),Object(i.b)("p",null,"Now our component doesn't have to worry about what the payload object looks like - the action creator will take care of putting it together the right way. So, we can update the component so that it passes in ",Object(i.b)("inlineCode",{parentName:"p"},"title")," and ",Object(i.b)("inlineCode",{parentName:"p"},"content")," as arguments when it dispatches ",Object(i.b)("inlineCode",{parentName:"p"},"postAdded"),":"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-jsx",metastring:'title="features/posts/AddPostForm.js"',title:'"features/posts/AddPostForm.js"'},"const onSavePostClicked = () => {\n  if (title && content) {\n    // highlight-next-line\n    dispatch(postAdded(title, content))\n    setTitle('')\n    setContent('')\n  }\n}\n")),Object(i.b)("h2",{id:"users-and-posts"},"Users and Posts"),Object(i.b)("p",null,"So far, we only have one slice of state. The logic is defined in ",Object(i.b)("inlineCode",{parentName:"p"},"postsSlice.js"),", the data is stored in ",Object(i.b)("inlineCode",{parentName:"p"},"state.posts"),', and all of our components have been related to the posts feature. Real applications will probably have many different slices of state, and several different "feature folders" for the Redux logic and React components.'),Object(i.b)("p",null,"You can't have a \"social media\" app if there aren't any other people involved. Let's add the ability to keep track of a list of users in our app, and update the post-related functionality to make use of that data."),Object(i.b)("h3",{id:"adding-a-users-slice"},"Adding a Users Slice"),Object(i.b)("p",null,'Since the concept of "users" is different than the concept of "posts", we want to keep the code and data for the users separated from the code and data for posts. We\'ll add a new ',Object(i.b)("inlineCode",{parentName:"p"},"features/users")," folder, and put a ",Object(i.b)("inlineCode",{parentName:"p"},"usersSlice")," file in there. Like with the posts slice, for now we'll add some initial entries so that we have data to work with."),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-js",metastring:'title="features/users/usersSlice.js"',title:'"features/users/usersSlice.js"'},"import { createSlice } from '@reduxjs/toolkit'\n\nconst initialState = [\n  { id: '0', name: 'Tianna Jenkins' },\n  { id: '1', name: 'Kevin Grant' },\n  { id: '2', name: 'Madison Price' }\n]\n\nconst usersSlice = createSlice({\n  name: 'users',\n  initialState,\n  reducers: {}\n})\n\nexport default usersSlice.reducer\n")),Object(i.b)("p",null,"For now, we don't need to actually update the data, so we'll leave the ",Object(i.b)("inlineCode",{parentName:"p"},"reducers")," field as an empty object. (We'll come back to this in a later section.)"),Object(i.b)("p",null,"As before, we'll import the ",Object(i.b)("inlineCode",{parentName:"p"},"usersReducer")," into our store file and add it to the store setup:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-js",metastring:'title="app/store.js"',title:'"app/store.js"'},"import { configureStore } from '@reduxjs/toolkit'\n\nimport postsReducer from '../features/posts/postsSlice'\n// highlight-next-line\nimport usersReducer from '../features/users/usersSlice'\n\nexport default configureStore({\n  reducer: {\n    posts: postsReducer,\n    // highlight-next-line\n    users: usersReducer\n  }\n})\n")),Object(i.b)("h3",{id:"adding-authors-for-posts"},"Adding Authors for Posts"),Object(i.b)("p",null,"Every post in our app was written by one of our users, and every time we add a new post, we should keep track of which user wrote that post. In a real app, we'd have some sort of a ",Object(i.b)("inlineCode",{parentName:"p"},"state.currentUser")," field that keeps track of the current logged-in user, and use that information whenever they add a post."),Object(i.b)("p",null,"To keep things simpler for this example, we'll update our ",Object(i.b)("inlineCode",{parentName:"p"},"<AddPostForm>")," component so that we can select a user from a dropdown list, and we'll include that user's ID as part of the post. Once our post objects have a user ID in them, we can use that to look up the user's name and show it in each individual post in the UI."),Object(i.b)("p",null,"First, we need to update our ",Object(i.b)("inlineCode",{parentName:"p"},"postAdded")," action creator to accept a user ID as an argument, and include that in the action. (We'll also update the existing post entries in ",Object(i.b)("inlineCode",{parentName:"p"},"initialState")," to have a ",Object(i.b)("inlineCode",{parentName:"p"},"post.user")," field with one of the example user IDs.)"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-js",metastring:'title="features/posts/postsSlice.js"',title:'"features/posts/postsSlice.js"'},"const postsSlice = createSlice({\n  name: 'posts',\n  initialState,\n  reducers: {\n    postAdded: {\n      reducer(state, action) {\n        state.push(action.payload)\n      },\n      // highlight-next-line\n      prepare(title, content, userId) {\n        return {\n          payload: {\n            id: nanoid(),\n            title,\n            content,\n            // highlight-next-line\n            user: userId\n          }\n        }\n      }\n    }\n    // other reducers\n  }\n})\n")),Object(i.b)("p",null,"Now, in our ",Object(i.b)("inlineCode",{parentName:"p"},"<AddPostForm>"),", we can read the list of users from the store with ",Object(i.b)("inlineCode",{parentName:"p"},"useSelector")," and show them as a dropdown. We'll then take the ID of the selected user and pass that to the ",Object(i.b)("inlineCode",{parentName:"p"},"postAdded"),' action creator. While we\'re at it, we can add a bit of validation logic to our form so that the user can only click the "Save Post" button if the title and content inputs have some actual text in them:'),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-jsx",metastring:'title="features/posts/AddPostForm.js"',title:'"features/posts/AddPostForm.js"'},'import React, { useState } from \'react\'\n// highlight-next-line\nimport { useDispatch, useSelector } from \'react-redux\'\n\nimport { postAdded } from \'./postsSlice\'\n\nexport const AddPostForm = () => {\n  const [title, setTitle] = useState(\'\')\n  const [content, setContent] = useState(\'\')\n  // highlight-next-line\n  const [userId, setUserId] = useState(\'\')\n\n  const dispatch = useDispatch()\n\n  // highlight-next-line\n  const users = useSelector(state => state.users)\n\n  const onTitleChanged = e => setTitle(e.target.value)\n  const onContentChanged = e => setContent(e.target.value)\n  // highlight-next-line\n  const onAuthorChanged = e => setUserId(e.target.value)\n\n  const onSavePostClicked = () => {\n    if (title && content) {\n      // highlight-next-line\n      dispatch(postAdded(title, content, userId))\n      setTitle(\'\')\n      setContent(\'\')\n    }\n  }\n\n  // highlight-start\n  const canSave = Boolean(title) && Boolean(content) && Boolean(userId)\n\n  const usersOptions = users.map(user => (\n    <option key={user.id} value={user.id}>\n      {user.name}\n    </option>\n  ))\n  // highlight-end\n\n  return (\n    <section>\n      <h2>Add a New Post</h2>\n      <form>\n        <label htmlFor="postTitle">Post Title:</label>\n        <input\n          type="text"\n          id="postTitle"\n          name="postTitle"\n          placeholder="What\'s on your mind?"\n          value={title}\n          onChange={onTitleChanged}\n        />\n        // highlight-start\n        <label htmlFor="postAuthor">Author:</label>\n        <select id="postAuthor" value={userId} onChange={onAuthorChanged}>\n          <option value=""></option>\n          {usersOptions}\n        </select>\n        // highlight-end\n        <label htmlFor="postContent">Content:</label>\n        <textarea\n          id="postContent"\n          name="postContent"\n          value={content}\n          onChange={onContentChanged}\n        />\n        // highlight-next-line\n        <button type="button" onClick={onSavePostClicked} disabled={!canSave}>\n          Save Post\n        </button>\n      </form>\n    </section>\n  )\n}\n')),Object(i.b)("p",null,"Now, we need a way to show the name of the post's author inside of our post list items and ",Object(i.b)("inlineCode",{parentName:"p"},"<SinglePostPage>"),". Since we want to show this same kind of info in more than one place, we can make a ",Object(i.b)("inlineCode",{parentName:"p"},"PostAuthor")," component that takes a user ID as a prop, looks up the right user object, and formats the user's name:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-jsx",metastring:'title="features/posts/PostAuthor.js"',title:'"features/posts/PostAuthor.js"'},"import React from 'react'\nimport { useSelector } from 'react-redux'\n\nexport const PostAuthor = ({ userId }) => {\n  const author = useSelector(state =>\n    state.users.find(user => user.id === userId)\n  )\n\n  return <span>by {author ? author.name : 'Unknown author'}</span>\n}\n")),Object(i.b)("p",null,"Notice that we're following the same pattern in each of our components as we go. Any component that needs to read data from the Redux store can use the ",Object(i.b)("inlineCode",{parentName:"p"},"useSelector")," hook, and extract the specific pieces of data that it needs. Also, many components can access the same data in the Redux store at the same time."),Object(i.b)("p",null,"We can now import the ",Object(i.b)("inlineCode",{parentName:"p"},"PostAuthor")," component into both ",Object(i.b)("inlineCode",{parentName:"p"},"PostsList.js")," and ",Object(i.b)("inlineCode",{parentName:"p"},"SinglePostPage.js"),", and render it as ",Object(i.b)("inlineCode",{parentName:"p"},"<PostAuthor userId={post.user} />"),", and every time we add a post entry, the selected user's name should show up inside of the rendered post."),Object(i.b)("h2",{id:"more-post-features"},"More Post Features"),Object(i.b)("p",null,"At this point, we can create and edit posts. Let's add some additional logic to make our posts feed more useful."),Object(i.b)("h3",{id:"storing-dates-for-posts"},"Storing Dates for Posts"),Object(i.b)("p",null,'Social media feeds are typically sorted by when the post was created, and show us the post creation time as a relative description like "5 hours ago". In order to do that, we need to start tracking a ',Object(i.b)("inlineCode",{parentName:"p"},"date")," field for our post entries."),Object(i.b)("p",null,"Like with the ",Object(i.b)("inlineCode",{parentName:"p"},"post.user")," field, we'll update our ",Object(i.b)("inlineCode",{parentName:"p"},"postAdded")," prepare callback to make sure that ",Object(i.b)("inlineCode",{parentName:"p"},"post.date")," is always included when the action is dispatched. However, it's not another parameter that will be passed in. We want to always use the exact timestamp from when the action is dispatched, so we'll let the prepare callback handle that itself."),Object(i.b)("div",{className:"admonition admonition-caution alert alert--warning"},Object(i.b)("div",{parentName:"div",className:"admonition-heading"},Object(i.b)("h5",{parentName:"div"},Object(i.b)("span",{parentName:"h5",className:"admonition-icon"},Object(i.b)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"16",height:"16",viewBox:"0 0 16 16"},Object(i.b)("path",{parentName:"svg",fillRule:"evenodd",d:"M8.893 1.5c-.183-.31-.52-.5-.887-.5s-.703.19-.886.5L.138 13.499a.98.98 0 0 0 0 1.001c.193.31.53.501.886.501h13.964c.367 0 .704-.19.877-.5a1.03 1.03 0 0 0 .01-1.002L8.893 1.5zm.133 11.497H6.987v-2.003h2.039v2.003zm0-3.004H6.987V5.987h2.039v4.006z"}))),"caution")),Object(i.b)("div",{parentName:"div",className:"admonition-content"},Object(i.b)("p",{parentName:"div"},Object(i.b)("strong",{parentName:"p"},"Redux actions and state should only contain plain JS values like objects, arrays, and primitives. Don't put class instances, functions, or other non-serializable values into Redux!"),"."))),Object(i.b)("p",null,"Since we can't just put a ",Object(i.b)("inlineCode",{parentName:"p"},"Date")," class instance into the Redux store, we'll track the ",Object(i.b)("inlineCode",{parentName:"p"},"post.date")," value as a timestamp string:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-js",metastring:'title="features/posts/postsSlice.js"',title:'"features/posts/postsSlice.js"'},"    postAdded: {\n      reducer(state, action) {\n        state.push(action.payload)\n      },\n      prepare(title, content, userId) {\n        return {\n          payload: {\n            id: nanoid(),\n            // highlight-next-line\n            date: new Date().toISOString(),\n            title,\n            content,\n            user: userId,\n          },\n        }\n      },\n    },\n")),Object(i.b)("p",null,"Like with post authors, we need to show the relative timestamp description in both our ",Object(i.b)("inlineCode",{parentName:"p"},"<PostsList>")," and ",Object(i.b)("inlineCode",{parentName:"p"},"<SinglePostPage>")," components. We'll add a ",Object(i.b)("inlineCode",{parentName:"p"},"<TimeAgo>")," component to handle formatting a timestamp string as a relative description. Libraries like ",Object(i.b)("inlineCode",{parentName:"p"},"date-fns")," have some useful utility functions for parsing and formatting dates, which we can use here:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-jsx",metastring:'title="features/posts/TimeAgo.js"',title:'"features/posts/TimeAgo.js"'},"import React from 'react'\nimport { parseISO, formatDistanceToNow } from 'date-fns'\n\nexport const TimeAgo = ({ timestamp }) => {\n  let timeAgo = ''\n  if (timestamp) {\n    const date = parseISO(timestamp)\n    const timePeriod = formatDistanceToNow(date)\n    timeAgo = `${timePeriod} ago`\n  }\n\n  return (\n    <span title={timestamp}>\n      &nbsp; <i>{timeAgo}</i>\n    </span>\n  )\n}\n")),Object(i.b)("h3",{id:"sorting-the-posts-list"},"Sorting the Posts List"),Object(i.b)("p",null,"Our ",Object(i.b)("inlineCode",{parentName:"p"},"<PostsList>")," is currently showing all the posts in the same order the posts are kept in the Redux store. Our example has the oldest post first, and any time we add a new post, it gets added to the end of the posts array. That means the newest post is always at the bottom of the page."),Object(i.b)("p",null,"Typically, social media feeds show the newest posts first, and you scroll down to see older posts. Even though the data is being kept oldest-first in the store, we can reorder the data in our ",Object(i.b)("inlineCode",{parentName:"p"},"<PostsList>")," component so that the newest post is first. In theory, since we know that the ",Object(i.b)("inlineCode",{parentName:"p"},"state.posts")," array is already sorted, we ",Object(i.b)("em",{parentName:"p"},"could")," just reverse the list. But, it's better to go ahead and sort it ourselves just to be sure."),Object(i.b)("p",null,"Since ",Object(i.b)("inlineCode",{parentName:"p"},"array.sort()")," mutates the existing array, we need to make a copy of ",Object(i.b)("inlineCode",{parentName:"p"},"state.posts")," and sort that copy. We know that our ",Object(i.b)("inlineCode",{parentName:"p"},"post.date")," fields are being kept as date timestamp strings, and we can directly compare those to sort the posts in the right order:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-jsx",metastring:'title="features/posts/PostsList.js"',title:'"features/posts/PostsList.js"'},'// Sort posts in reverse chronological order by datetime string\n//highlight-start\nconst orderedPosts = posts.slice().sort((a, b) => b.date.localeCompare(a.date))\n\nconst renderedPosts = orderedPosts.map(post => {\n  //highlight-end\n  return (\n    <article className="post-excerpt" key={post.id}>\n      <h3>{post.title}</h3>\n      <div>\n        <PostAuthor userId={post.user} />\n        <TimeAgo timestamp={post.date} />\n      </div>\n      <p className="post-content">{post.content.substring(0, 100)}</p>\n      <Link to={`/posts/${post.id}`} className="button muted-button">\n        View Post\n      </Link>\n    </article>\n  )\n})\n')),Object(i.b)("p",null,"We also need to add the ",Object(i.b)("inlineCode",{parentName:"p"},"date")," field to ",Object(i.b)("inlineCode",{parentName:"p"},"initialState")," in ",Object(i.b)("inlineCode",{parentName:"p"},"postsSlice.js"),". We'll use ",Object(i.b)("inlineCode",{parentName:"p"},"date-fns")," here again to subtract minutes from the current date/time so they differ from each other."),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-jsx",metastring:'title="features/posts/postsSlice.js"',title:'"features/posts/postsSlice.js"'},"import { createSlice, nanoid } from '@reduxjs/toolkit'\n// highlight-next-line\nimport { sub } from 'date-fns'\n\nconst initialState = [\n  {\n    // omitted fields\n    content: 'Hello!',\n    // highlight-next-line\n    date: sub(new Date(), { minutes: 10 }).toISOString()\n  },\n  {\n    // omitted fields\n    content: 'More text',\n    // highlight-next-line\n    date: sub(new Date(), { minutes: 5 }).toISOString()\n  }\n]\n")),Object(i.b)("h3",{id:"post-reaction-buttons"},"Post Reaction Buttons"),Object(i.b)("p",null,"We have one more new feature to add for this section. Right now, our posts are kind of boring. We need to make them more exciting, and what better way to do that than letting our friends add reaction emoji to our posts?"),Object(i.b)("p",null,"We'll add a row of emoji reaction buttons at the bottom of each post in ",Object(i.b)("inlineCode",{parentName:"p"},"<PostsList>")," and ",Object(i.b)("inlineCode",{parentName:"p"},"<SinglePostPage>"),". Every time a user clicks one of the reaction buttons, we'll need to update a matching counter field for that post in the Redux store. Since the reaction counter data is in the Redux store, switching between different parts of the app should consistently show the same values in any component that uses that data."),Object(i.b)("p",null,"Like with post authors and timestamps, we want to use this everywhere we show posts, so we'll create a ",Object(i.b)("inlineCode",{parentName:"p"},"<ReactionButtons>")," component that takes a ",Object(i.b)("inlineCode",{parentName:"p"},"post")," as a prop. We'll start by just showing the buttons inside, with the current reaction counts for each button:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-jsx",metastring:'title="features/posts/ReactionButtons.js"',title:'"features/posts/ReactionButtons.js"'},"import React from 'react'\n\nconst reactionEmoji = {\n  thumbsUp: '\ud83d\udc4d',\n  hooray: '\ud83c\udf89',\n  heart: '\u2764\ufe0f',\n  rocket: '\ud83d\ude80',\n  eyes: '\ud83d\udc40'\n}\n\nexport const ReactionButtons = ({ post }) => {\n  const reactionButtons = Object.entries(reactionEmoji).map(([name, emoji]) => {\n    return (\n      <button key={name} type=\"button\" className=\"muted-button reaction-button\">\n        {emoji} {post.reactions[name]}\n      </button>\n    )\n  })\n\n  return <div>{reactionButtons}</div>\n}\n")),Object(i.b)("p",null,"We don't yet have a ",Object(i.b)("inlineCode",{parentName:"p"},"post.reactions")," field in our data, so we'll need to update the ",Object(i.b)("inlineCode",{parentName:"p"},"initialState")," post objects and our ",Object(i.b)("inlineCode",{parentName:"p"},"postAdded")," prepare callback function to make sure that every post has that data inside, like ",Object(i.b)("inlineCode",{parentName:"p"},"reactions: {thumbsUp: 0, hooray: 0}"),"."),Object(i.b)("p",null,"Now, we can define a new reducer that will handle updating the reaction count for a post when a user clicks the reaction button."),Object(i.b)("p",null,"Like with editing posts, we need to know the ID of the post, and which reaction button the user clicked on. We'll have our ",Object(i.b)("inlineCode",{parentName:"p"},"action.payload")," be an object that looks like ",Object(i.b)("inlineCode",{parentName:"p"},"{id, reaction}"),". The reducer can then find the right post object, and update the correct reactions field."),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-js"},"const postsSlice = createSlice({\n  name: 'posts',\n  initialState,\n  reducers: {\n    // highlight-start\n    reactionAdded(state, action) {\n      const { postId, reaction } = action.payload\n      const existingPost = state.find(post => post.id === postId)\n      if (existingPost) {\n        existingPost.reactions[reaction]++\n      }\n    }\n    // highlight-end\n    // other reducers\n  }\n})\n\n// highlight-next-line\nexport const { postAdded, postUpdated, reactionAdded } = postsSlice.actions\n")),Object(i.b)("p",null,"As we've seen already, ",Object(i.b)("inlineCode",{parentName:"p"},"createSlice"),' lets us write "mutating" logic in our reducers. If we weren\'t using ',Object(i.b)("inlineCode",{parentName:"p"},"createSlice")," and the Immer library, the line ",Object(i.b)("inlineCode",{parentName:"p"},"existingPost.reactions[reaction]++")," would indeed mutate the existing ",Object(i.b)("inlineCode",{parentName:"p"},"post.reactions")," object, and this would probably cause bugs elsewhere in our app because we didn't follow the rules of reducers. But, since we ",Object(i.b)("em",{parentName:"p"},"are")," using ",Object(i.b)("inlineCode",{parentName:"p"},"createSlice"),", we can write this more complex update logic in a simpler way, and let Immer do the work of turning this code into a safe immutable update."),Object(i.b)("p",null,"Notice that ",Object(i.b)("strong",{parentName:"p"},"our action object just contains the minimum amount of information needed to describe what happened"),". We know which post we need to update, and which reaction name was clicked on. We ",Object(i.b)("em",{parentName:"p"},"could")," have calculated the new reaction counter value and put that in the action, but ",Object(i.b)("strong",{parentName:"p"},"it's always better to keep the action objects as small as possible, and do the state update calculations in the reducer"),". This also means that ",Object(i.b)("strong",{parentName:"p"},"reducers can contain as much logic as necessary to calculate the new state"),"."),Object(i.b)("div",{className:"admonition admonition-info alert alert--info"},Object(i.b)("div",{parentName:"div",className:"admonition-heading"},Object(i.b)("h5",{parentName:"div"},Object(i.b)("span",{parentName:"h5",className:"admonition-icon"},Object(i.b)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},Object(i.b)("path",{parentName:"svg",fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}))),"info")),Object(i.b)("div",{parentName:"div",className:"admonition-content"},Object(i.b)("p",{parentName:"div"},'When using Immer, you can either "mutate" an existing state object, or return a new state value yourself, but not both at the same time. See the Immer docs guides on ',Object(i.b)("a",{parentName:"p",href:"https://immerjs.github.io/immer/pitfalls"},"Pitfalls")," and ",Object(i.b)("a",{parentName:"p",href:"https://immerjs.github.io/immer/return"},"Returning New Data")," for more details."))),Object(i.b)("p",null,"Our last step is to update the ",Object(i.b)("inlineCode",{parentName:"p"},"<ReactionButtons>")," component to dispatch the ",Object(i.b)("inlineCode",{parentName:"p"},"reactionAdded")," action when the user clicks a button:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-jsx",metastring:'title="features/posts/ReactionButtons.jsx"',title:'"features/posts/ReactionButtons.jsx"'},"import React from 'react'\n// highlight-start\nimport { useDispatch } from 'react-redux'\n\nimport { reactionAdded } from './postsSlice'\n// highlight-end\n\nconst reactionEmoji = {\n  thumbsUp: '\ud83d\udc4d',\n  hooray: '\ud83c\udf89',\n  heart: '\u2764\ufe0f',\n  rocket: '\ud83d\ude80',\n  eyes: '\ud83d\udc40'\n}\n\nexport const ReactionButtons = ({ post }) => {\n  // highlight-next-line\n  const dispatch = useDispatch()\n\n  const reactionButtons = Object.entries(reactionEmoji).map(([name, emoji]) => {\n    return (\n      <button\n        key={name}\n        type=\"button\"\n        className=\"muted-button reaction-button\"\n        // highlight-start\n        onClick={() =>\n          dispatch(reactionAdded({ postId: post.id, reaction: name }))\n        }\n        // highlight-end\n      >\n        {emoji} {post.reactions[name]}\n      </button>\n    )\n  })\n\n  return <div>{reactionButtons}</div>\n}\n")),Object(i.b)("p",null,"Now, every time we click a reaction button, the counter should increment. If we browse around to different parts of the app, we should see the correct counter values displayed any time we look at this post, even if we click a reaction button in the ",Object(i.b)("inlineCode",{parentName:"p"},"<PostsList>")," and then look at the post by itself on the ",Object(i.b)("inlineCode",{parentName:"p"},"<SinglePostPage>"),"."),Object(i.b)("h2",{id:"what-youve-learned"},"What You've Learned"),Object(i.b)("p",null,"Here's what our app looks like after all these changes:"),Object(i.b)("iframe",{class:"codesandbox",src:"https://codesandbox.io/embed/github/reduxjs/redux-essentials-example-app/tree/checkpoint-2-reactionButtons/?fontsize=14&hidenavigation=1&theme=dark&runonclick=1",title:"redux-essentials-example-app",allow:"geolocation; microphone; camera; midi; vr; accelerometer; gyroscope; payment; ambient-light-sensor; encrypted-media; usb",sandbox:"allow-modals allow-forms allow-popups allow-scripts allow-same-origin"}),Object(i.b)("p",null,"It's actually starting to look more useful and interesting!"),Object(i.b)("p",null,"We've covered a lot of information and concepts in this section. Let's recap the important things to remember:"),Object(i.b)("div",{className:"admonition admonition-tip alert alert--success"},Object(i.b)("div",{parentName:"div",className:"admonition-heading"},Object(i.b)("h5",{parentName:"div"},Object(i.b)("span",{parentName:"h5",className:"admonition-icon"},Object(i.b)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},Object(i.b)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"Summary")),Object(i.b)("div",{parentName:"div",className:"admonition-content"},Object(i.b)("ul",{parentName:"div"},Object(i.b)("li",{parentName:"ul"},Object(i.b)("strong",{parentName:"li"},"Any React component can use data from the Redux store as needed"),Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},"Any component can read any data that is in the Redux store"),Object(i.b)("li",{parentName:"ul"},"Multiple components can read the same data, even at the same time"),Object(i.b)("li",{parentName:"ul"},"Components should extract the smallest amount of data they need to render themselves"),Object(i.b)("li",{parentName:"ul"},"Components can combine values from props, state, and the Redux store to determine what UI they need to render. They can read multiple pieces of data from the store, and reshape the data as needed for display."),Object(i.b)("li",{parentName:"ul"},"Any component can dispatch actions to cause state updates"))),Object(i.b)("li",{parentName:"ul"},Object(i.b)("strong",{parentName:"li"},"Redux action creators can prepare action objects with the right contents"),Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"createSlice")," and ",Object(i.b)("inlineCode",{parentName:"li"},"createAction"),' can accept a "prepare callback" that returns the action payload'),Object(i.b)("li",{parentName:"ul"},"Unique IDs and other random values should be put in the action, not calculated in the reducer"))),Object(i.b)("li",{parentName:"ul"},Object(i.b)("strong",{parentName:"li"},"Reducers should contain the actual state update logic"),Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},"Reducers can contain whatever logic is needed to calculate the next state"),Object(i.b)("li",{parentName:"ul"},"Action objects should contain just enough info to describe what happened")))))),Object(i.b)("h2",{id:"whats-next"},"What's Next?"),Object(i.b)("p",null,"By now you should be comfortable working with data in the Redux store and React components. So far we've just used data that was in the initial state or added by the user. In ",Object(i.b)("a",{parentName:"p",href:"/tutorials/essentials/part-5-async-logic"},"Part 5: Async Logic and Data Fetching"),", we'll see how to work with data that comes from a server API."))}d.isMDXComponent=!0},158:function(e,t,n){"use strict";n.d(t,"a",(function(){return p})),n.d(t,"b",(function(){return b}));var a=n(0),o=n.n(a);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=o.a.createContext({}),d=function(e){var t=o.a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},p=function(e){var t=d(e.components);return o.a.createElement(l.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return o.a.createElement(o.a.Fragment,{},t)}},u=o.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,s=e.parentName,l=c(e,["components","mdxType","originalType","parentName"]),p=d(n),u=a,b=p["".concat(s,".").concat(u)]||p[u]||h[u]||i;return n?o.a.createElement(b,r(r({ref:t},l),{},{components:n})):o.a.createElement(b,r({ref:t},l))}));function b(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,s=new Array(i);s[0]=u;var r={};for(var c in t)hasOwnProperty.call(t,c)&&(r[c]=t[c]);r.originalType=e,r.mdxType="string"==typeof e?e:a,s[1]=r;for(var l=2;l<i;l++)s[l]=n[l];return o.a.createElement.apply(null,s)}return o.a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},159:function(e,t,n){"use strict";n.d(t,"b",(function(){return p})),n.d(t,"a",(function(){return h}));var a=n(0),o=n.n(a);const i=/{\w+}/g,s="{}";function r(e,t){const n=[],a=e.replace(i,(e=>{const a=e.substr(1,e.length-2),i=null==t?void 0:t[a];if(void 0!==i){const e=o.a.isValidElement(i)?i:String(i);return n.push(e),s}return e}));return 0===n.length?e:n.every((e=>"string"==typeof e))?a.split(s).reduce(((e,t,a)=>{var o;return e.concat(t).concat(null!==(o=n[a])&&void 0!==o?o:"")}),""):a.split(s).reduce(((e,t,a)=>[...e,o.a.createElement(o.a.Fragment,{key:a},t,n[a])]),[])}function c({children:e,values:t}){return r(e,t)}var l=n(23);function d({id:e,message:t}){var n;return null!==(n=l[null!=e?e:t])&&void 0!==n?n:t}function p({message:e,id:t},n){var a;return r(null!==(a=d({message:e,id:t}))&&void 0!==a?a:e,n)}function h({children:e,id:t,values:n}){var a;const i=null!==(a=d({message:e,id:t}))&&void 0!==a?a:e;return o.a.createElement(c,{values:n},i)}},160:function(e,t,n){"use strict";n.d(t,"a",(function(){return s}));var a=n(0),o=n.n(a),i=n(159);const s=({children:e,title:t=Object(i.b)({message:"Detailed Explanation"})})=>o.a.createElement("details",{className:"detailed-explanation"},o.a.createElement("summary",null,o.a.createElement("h4",null,t)),e)}}]);